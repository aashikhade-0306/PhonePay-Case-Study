# -*- coding: utf-8 -*-
"""PhonePay Case Study.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b0Pd62UstFwTvA4X4McUhZZehWhD1MMM
"""

import pandas as pd

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"

project_dir = r'C:\Users\khade\Downloads'

os.getcwd()
os.chdir(project_dir)
os.getcwd()

df = pd.read_excel(r'C:\Users\khade\Downloads\phonepe-pulse_raw-data_q12018-to-q22021-v0-1-5-1720351752.xlsx')
df.head()
df.shape

import pandas as pd
# 1 Data Loading and Understanding (1.1,1.2)
# Define the path to your Excel file
excel_file = r'C:\Users\khade\Downloads\phonepe-pulse_raw-data_q12018-to-q22021-v0-1-5-1720351752.xlsx'

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Display the first few rows of each dataframe to verify
print(state_txn_users_df.head())

# Display bottom 10 rows of State_TxnSplit
print(state_txn_split_df.head(10))

# Display 10 rows from the middle of State_DeviceData
# print(state_device_data_df.head())
middle_idx = len(state_device_data_df) // 2
print(state_device_data_df.iloc[middle_idx-5:middle_idx+5])

# Display first 10 rows and last 10 rows of District_Txn and Users
print(district_txn_users_df.head(10))

# Display every 10th row of District_Demographics
# print(district_demographics_df.head())
print(district_demographics_df.iloc[::10])

# 1.2
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']




# Function to display basic statistics and data types
def display_statistics_and_dtypes(df, sheet_name):
    print(f"Summary statistics for {sheet_name}:\n")
    print(df.describe(include='all'))  # Summary statistics for numerical columns
    print("\nData types for each column:\n")
    print(df.dtypes)  # Data types of each column
    print("\n" + "="*80 + "\n")

# Display statistics and data types for each dataset
display_statistics_and_dtypes(state_txn_users_df, 'State_Txn and Users')
display_statistics_and_dtypes(state_txn_split_df, 'xls.State_TxnSplit')
display_statistics_and_dtypes(state_device_data_df, 'xls.State_DeviceData')
display_statistics_and_dtypes(district_txn_users_df, 'District_Txn and Users')
display_statistics_and_dtypes(district_demographics_df, 'District Demographics')

# 1.3
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']



# Function to check for missing values and calculate percentages
def check_missing_values(df, sheet_name):
    print(f"Missing values analysis for {sheet_name}:\n")
    # Calculate the number of missing values for each column
    missing_values = df.isnull().sum()
    # Calculate the percentage of missing values for each column
    missing_percentage = (missing_values / len(df)) * 100
    # Filter out columns that have missing values
    missing_data = pd.DataFrame({'Missing Values': missing_values, 'Percentage': missing_percentage})
    missing_data = missing_data[missing_data['Missing Values'] > 0]

    if not missing_data.empty:
        print(missing_data)
        # Identify the column with the highest percentage of missing values
        max_missing_column = missing_data['Percentage'].idxmax()
        max_missing_percentage = missing_data['Percentage'].max()
        print(f"\nColumn with the highest percentage of missing values: {max_missing_column} ({max_missing_percentage:.2f}%)")
    else:
        print("No missing values in this dataset.")
    print("\n" + "-"*80 + "\n")

# Access and process each sheet
for sheet_name in sheet_names:
    df = xls[sheet_name]
    check_missing_values(df, sheet_name)

# 1.4
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']


# Assuming 'State' and 'District' columns exist in the relevant sheets

# Combine relevant sheets if necessary
state_txn_users_df = xls['State_Txn and Users']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Calculate the total number of states
total_states = state_txn_users_df['State'].nunique()
print(f"Total number of states: {total_states}")

# Calculate the total number of districts
total_districts = district_demographics_df['District'].nunique()
print(f"Total number of districts: {total_districts}")

# Identify the state with the highest number of districts
state_district_counts = district_demographics_df['State'].value_counts()
state_with_most_districts = state_district_counts.idxmax()
num_districts_in_state = state_district_counts.max()

print(f"The state with the highest number of districts is: {state_with_most_districts} with {num_districts_in_state} districts")

# Display the state district counts for verification
print("\nState district counts:\n")
print(state_district_counts)

# 2.1
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']


# Assuming 'State', 'Year', 'TransactionCount', and 'TransactionAmount' columns exist in the relevant sheets
state_txn_users_df = xls['State_Txn and Users']

# Calculate the total number of transactions and total transaction amount for each state over the years
state_transactions = state_txn_users_df.groupby('State').agg({
    'Transactions': 'sum',
    'Transactions': 'sum'
}).reset_index()

# Display the results in a tabular format
print("Total number of transactions and total transaction amount for each state over the years:")
print(state_transactions)

# Identify the top 5 states with the highest transaction volumes
top_5_states_highest_transactions = state_transactions.nlargest(5, 'Transactions')
print("\nTop 5 states with the highest transaction volumes:")
print(top_5_states_highest_transactions)

# Identify the top 5 states with the lowest transaction volumes
top_5_states_lowest_transactions = state_transactions.nsmallest(5, 'Transactions')
print("\nTop 5 states with the lowest transaction volumes:")
print(top_5_states_lowest_transactions)

# 2.2
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'State_Txn and Users' sheet
state_txn_split_df = xls['State_TxnSplit']

# Assuming the DataFrame has the following columns: 'State', 'Quarter', 'TransactionType'
# Group the data by 'State' and 'Quarter', then find the most frequent 'TransactionType'
most_common_transactions = state_txn_split_df.groupby(['State', 'Quarter'])['TransactionType'].agg(lambda x: x.value_counts().idxmax()).reset_index()

# Rename columns for better clarity
most_common_transactions.columns = ['State', 'Quarter', 'MostCommonTransactionType']

# Display the results in a tabular format
print("Most common transaction types in each state and quarter:")
print(most_common_transactions)

# 2.3
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# # Access each sheet
# state_txn_users_df = xls['State_Txn and Users']
# state_txn_split_df = xls['State_TxnSplit']
# state_device_data_df = xls['State_DeviceData']
# district_txn_users_df = xls['District_Txn and Users']
# district_demographics_df = xls['District Demographics']

# Access the 'xls.State_DeviceData' sheet
state_device_data_df = xls['State_DeviceData']

# Assuming the DataFrame has the following columns: 'State', 'DeviceBrand'
# Group the data by 'State' and 'DeviceBrand', and count the number of registered users for each brand
device_brand_counts = state_device_data_df.groupby(['State', 'Brand']).size().reset_index(name='UserCount')

# For each state, find the device brand with the highest number of registered users
max_device_brand_per_state = device_brand_counts.loc[device_brand_counts.groupby('State')['UserCount'].idxmax()]

# Display the results in a tabular format
print("Device brand with the highest number of registered users in each state:")
print(max_device_brand_per_state)

# 2.4
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
# state_txn_users_df = xls['State_Txn and Users']
# state_txn_split_df = xls['State_TxnSplit']
# state_device_data_df = xls['State_DeviceData']
# district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'District Demographics' sheet
district_demographics_df = xls['District Demographics']

# Assuming the DataFrame has the following columns: 'State', 'District', 'Population'
# Group the data by 'State' and find the district with the highest population in each state
max_population_per_state = district_demographics_df.loc[district_demographics_df.groupby('State')['Population'].idxmax()]

# Display the results in a tabular format
print("District with the highest population in each state:")
print(max_population_per_state[['State', 'District', 'Population']])

# Create a column chart depicting the district with the highest population for each state
plt.figure(figsize=(10, 8))
plt.bar(max_population_per_state['State'], max_population_per_state['Population'], color='skyblue')
plt.xlabel('State')
plt.ylabel('Population')
plt.title('District with the Highest Population for Each State')
plt.xticks(rotation=90)
plt.tight_layout()

# Show the plot
plt.show()

# 2.5
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']

# Assuming the DataFrame has the following columns: 'State', 'TransactionAmount', 'TransactionCount'
# Calculate the average transaction value (ATV) for each state
state_atv = state_txn_users_df.groupby('State').apply(
    lambda x: x['Amount (INR)'].sum() / x['Transactions'].sum()
).reset_index(name='AverageTransactionValue')

# Display the results in a tabular format
print("Average Transaction Value (ATV) for each state:")
print(state_atv)

# Identify the top 5 states with the highest ATV
top_5_states_highest_atv = state_atv.nlargest(5, 'AverageTransactionValue')
print("\nTop 5 states with the highest ATV:")
print(top_5_states_highest_atv)

# Identify the top 5 states with the lowest ATV
top_5_states_lowest_atv = state_atv.nsmallest(5, 'AverageTransactionValue')
print("\nTop 5 states with the lowest ATV:")
print(top_5_states_lowest_atv)

# 2.6
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Assuming the DataFrame has the following columns: 'State', 'Year', 'Quarter', 'AppOpens'
# Calculate the total number of app opens over the years and quarters for each state
app_opens_summary = state_txn_users_df.groupby(['State', 'Year', 'Quarter']).agg({
    'App Opens': 'sum'
}).reset_index()

# Display the results in a tabular format
print("Total number of app opens over the years and quarters for each state:")
print(app_opens_summary)


# Select the state you want to analyze
selected_state = 'YourSelectedState'  # Replace with the state of interest

# Filter the data for the selected state
state_data = state_txn_split_df[state_txn_split_df['State'] == selected_state]
state_data = state_txn_users_df[state_txn_users_df['State'] == selected_state]
# Group by Year and Quarter and sum the AppOpens
state_trends = state_txn_users_df.groupby(['Year', 'Quarter']).agg({
    'App Opens': 'sum'
}).reset_index()

# Create a line plot
plt.figure(figsize=(12, 6))
plt.plot(state_trends['Year'].astype(str) + ' Q' + state_trends['Quarter'].astype(str),
         state_trends['App Opens'], marker='o', linestyle='-')
plt.xlabel('Time (Year and Quarter)')
plt.ylabel('Number of App Opens')
plt.title(f'Number of App Opens Over Time for {selected_state}')
plt.xticks(rotation=90)
plt.grid(True)
plt.tight_layout()

# Show the plot
plt.show()

# 2.7
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']


# Access the 'State_Txn and Users' sheet
state_txn_users_df = xls['State_Txn and Users']

# Assuming the DataFrame has the following columns: 'State', 'Quarter', 'TransactionType'
# Identify the most recent quarter
most_recent_quarter = state_txn_users_df['Quarter'].max()
most_recent_year = state_txn_users_df[state_txn_users_df['Quarter'] == most_recent_quarter]['Year'].max()

# Filter the data for the most recent quarter
recent_quarter_data = state_txn_split_df [(state_txn_split_df ['Year'] == most_recent_year) &
                                         (state_txn_split_df ['Quarter'] == most_recent_quarter)]

# Group by 'State' and 'TransactionType' and count occurrences
transaction_distribution = recent_quarter_data.groupby(['State', 'Transaction Type']).size().unstack(fill_value=0)

# Plot the bar chart
transaction_distribution.plot(kind='bar', figsize=(14, 8), stacked=True, colormap='tab20')
plt.xlabel('State')
plt.ylabel('Number of Transactions')
plt.title(f'Distribution of Transaction Types for Each State in Q{most_recent_quarter} {most_recent_year}')
plt.legend(title='Transaction Type')
plt.xticks(rotation=45)
plt.tight_layout()

# Show the plot
plt.show()

# 2.9
import pandas as pd

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'District Demographics' sheet
district_demographics_df = xls['District Demographics']

# Assuming the DataFrame has the following columns: 'DistrictName' and 'DistrictCode'
# Find unique mappings between district names and district codes
unique_district_mappings = district_demographics_df[['District', 'Code']].drop_duplicates()

# Define the path for the output CSV file
csv_file_path = 'unique_district_mappings.csv'

# Export the unique mappings to a CSV file
unique_district_mappings.to_csv(csv_file_path, index=False)

print(f"Unique district mappings have been exported to {csv_file_path}")

# 3.Data Qualty Check(3.1)
import pandas as pd

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']


# Access the 'District_Txn and Users' and 'State_Txn and Users' sheets
district_txn_users_df = xls['District_Txn and Users']
state_txn_users_df = xls['State_Txn and Users']

# Calculate totals at the district level
district_totals = district_txn_users_df.groupby('State').agg({
    'Amount (INR)': 'sum',
    'Transactions': 'sum',
    'Registered Users': 'sum'
}).reset_index()

# Calculate totals at the state level
state_totals = state_txn_users_df.groupby('State').agg({
    'Amount (INR)': 'sum',
    'Transactions': 'sum',
    'Registered Users': 'sum'
}).reset_index()

# Merge the district and state totals for comparison
comparison_df = pd.merge(district_totals, state_totals, on='State', suffixes=('_District', '_State'))

# Find discrepancies
discrepancies = comparison_df[
    (comparison_df['Amount (INR)_District'] != comparison_df['Amount (INR)_State']) |
    (comparison_df['Transactions_District'] != comparison_df['Transactions_State']) |
    (comparison_df['Registered Users_District'] != comparison_df['Registered Users_State'])
]

# Display the discrepancies
if not discrepancies.empty:
    print("Discrepancies found between district-level and state-level data:")
    print(discrepancies)
else:
    print("No discrepancies found between district-level and state-level data.")

# 4. Data merging and Advanced Analysis(4.1)
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'State_Txn and Users' and 'District Demographics' sheets
state_txn_users_df = xls['State_Txn and Users']
district_demographics_df = xls['District Demographics']

# Assuming the State_Txn and Users DataFrame has columns: 'State', 'RegisteredUsers'
# Assuming the District Demographics DataFrame has columns: 'State', 'Population'

# Aggregate registered users at the state level
state_registered_users = state_txn_users_df.groupby('State').agg({
    'Registered Users': 'sum'
}).reset_index()

# Aggregate population at the state level
state_population = district_demographics_df.groupby('State').agg({
    'Population': 'sum'
}).reset_index()

# Merge the two DataFrames on 'State'
state_data = pd.merge(state_registered_users, state_population, on='State')

# Calculate the ratio of users to population
state_data['UserToPopulationRatio'] = state_data['Registered Users'] / state_data['Population']

# Display the results in a tabular format
print("Ratio of registered users to population by state:")
print(state_data[['State', 'UserToPopulationRatio']])

# Create a column chart depicting the ratio of users to population by state
plt.figure(figsize=(12, 6))
plt.bar(state_data['State'], state_data['UserToPopulationRatio'], color='orange')
plt.xlabel('State')
plt.ylabel('Ratio of Users to Population')
plt.title('Ratio of Registered Users to Population by State')
plt.xticks(rotation=45)
plt.tight_layout()

# Show the plot
plt.show()

# 4.2
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'District_Txn and Users' and 'District Demographics' sheets
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Assuming the District_Txn and Users DataFrame has columns: 'District', 'TransactionVolume'
# Assuming the District Demographics DataFrame has columns: 'District', 'Population', 'Area'

# Calculate population density
district_demographics_df['PopulationDensity'] = district_demographics_df['Population'] / district_demographics_df['Area (sq km)']

# Merge the two DataFrames on 'District'
merged_df = pd.merge(district_txn_users_df, district_demographics_df[['District', 'PopulationDensity']], on='District')

# Calculate the correlation between population density and transaction volume
correlation = merged_df[['PopulationDensity', 'Transactions']].corr().iloc[0, 1]

print(f"Correlation between population density and transaction volume: {correlation}")

# Create a scatter plot to visualize the correlation
plt.figure(figsize=(10, 6))
plt.scatter(merged_df['PopulationDensity'], merged_df['Transactions'], alpha=0.5, color='green')
plt.xlabel('Population Density')
plt.ylabel('Transaction Volume')
plt.title('Correlation between Population Density and Transaction Volume')
plt.grid(True)
plt.tight_layout()

# Show the plot
plt.show()

# 4.3

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'State_Txn and Users' and 'District_Txn and Users' sheets
state_txn_users_df = xls['State_Txn and Users']
district_txn_users_df = xls['District_Txn and Users']

# Assuming the State_Txn and Users DataFrame has columns: 'State', 'RegisteredUsers'
# Assuming the District_Txn and Users DataFrame has columns: 'State', 'TransactionAmount'

# Aggregate transaction amount and registered users at the state level
state_transaction_amount = district_txn_users_df.groupby('State').agg({
    'Amount (INR)': 'sum'
}).reset_index()

state_registered_users = state_txn_users_df.groupby('State').agg({
    'Registered Users': 'sum'
}).reset_index()

# Merge the two DataFrames on 'State'
state_data = pd.merge(state_transaction_amount, state_registered_users, on='State')

# Calculate average transaction amount per user
state_data['AverageTransactionAmountPerUser'] = state_data['Amount (INR)'] / state_data['Registered Users']

# Display the results in tabular format
print("Average transaction amount per user for each state:")
print(state_data[['State', 'AverageTransactionAmountPerUser']])

# Identify the top 5 states with the highest average transaction amount per user
top_5_states = state_data.nlargest(5, 'AverageTransactionAmountPerUser')

# Identify the top 5 states with the lowest average transaction amount per user
bottom_5_states = state_data.nsmallest(5, 'AverageTransactionAmountPerUser')

# Display the results
print("\nTop 5 states with the highest average transaction amount per user:")
print(top_5_states[['State', 'AverageTransactionAmountPerUser']])

print("\nTop 5 states with the lowest average transaction amount per user:")
print(bottom_5_states[['State', 'AverageTransactionAmountPerUser']])

# 4.4

import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']


# Access the 'State_Txn and Users' and 'State_DeviceData' sheets
state_txn_users_df = xls['State_Txn and Users']
state_device_data_df = xls['State_DeviceData']

# Assuming the State_Txn and Users DataFrame has columns: 'State', 'RegisteredUsers'
# Assuming the State_DeviceData DataFrame has columns: 'State', 'DeviceBrand', 'UserCount'

# Merge the State_DeviceData with State_Txn and Users on 'State'
merged_df = pd.merge(state_device_data_df, state_txn_users_df[['State', 'Registered Users']], on='State')

# Calculate the ratio of users using each device brand to the total number of registered users in each state
merged_df['DeviceUsageRatio'] = state_device_data_df['Registered Users'] / state_txn_users_df['Registered Users']

# Display the results in a tabular format
device_usage_ratio_df = merged_df[['State', 'Brand', 'DeviceUsageRatio']]
print("Device brand usage ratio for each state:")
print(device_usage_ratio_df)

# Create a bar chart depicting the device brand usage ratio for each state
plt.figure(figsize=(14, 8))

# Plotting each state
for state in device_usage_ratio_df['State'].unique():
    state_data = device_usage_ratio_df[device_usage_ratio_df['State'] == state]
    plt.bar(state_data['Brand'], state_data['DeviceUsageRatio'], label=state)

plt.xlabel('Brand')
plt.ylabel('Usage Ratio')
plt.title('Device Brand Usage Ratio for Each State')
plt.legend(title='State', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(rotation=45)
plt.tight_layout()

# Show the plot
plt.show()

# Print column names of the state_txn_users_df
print(state_txn_users_df.columns)

# 5 Data Visualization
# 5.1
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'State_Txn and Users' sheet
state_txn_users_df = xls['State_Txn and Users']
district_txn_users_df = xls['District_Txn and Users']

# Select the state with the maximum transactions or any specific state
selected_state = 'YourHomeState'  # Replace with your home state or a state with max transactions

# Filter data for the selected state
district_txn_users_df = district_txn_users_df[district_txn_users_df['State'] == selected_state]

# Assuming the data has columns: 'Year', 'Quarter', 'TransactionCount', 'TransactionAmount'
# Group by 'Year' and 'Quarter' to aggregate transactions and transaction amounts
aggregated_data = state_txn_users_df.groupby(['Year', 'Quarter']).agg({
    'Transactions': 'sum',
    'Amount (INR)': 'sum'
}).reset_index()

# Create the line plot
fig, ax1 = plt.subplots(figsize=(14, 8))

ax1.set_xlabel('Time (Year and Quarter)')
ax1.set_ylabel('Total Transactions', color='tab:blue')
ax1.plot(aggregated_data['Year'].astype(str) + 'Q' + aggregated_data['Quarter'].astype(str), aggregated_data['Transactions'], color='tab:blue', label='Total Transactions')
ax1.tick_params(axis='y', labelcolor='tab:blue')

# Create a second y-axis to plot the total transaction amount
ax2 = ax1.twinx()
ax2.set_ylabel('Total Transaction Amount', color='tab:green')
ax2.plot(aggregated_data['Year'].astype(str) + 'Q' + aggregated_data['Quarter'].astype(str), aggregated_data['Amount (INR)'], color='tab:green', label='Total Transaction Amount')
ax2.tick_params(axis='y', labelcolor='tab:green')

# Add a title and legend
plt.title(f'Total Transactions and Transaction Amount Over Time for {selected_state}')
fig.tight_layout()
fig.legend(loc='upper left', bbox_to_anchor=(0.1,0.9))

# Rotate x-axis labels for better readability
plt.xticks(rotation=45)

# Show the plot
plt.show()

# 5.2
import pandas as pd
import matplotlib.pyplot as plt

# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access the 'State_Txn and Users' sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
district_txn_users_df = xls['District_Txn and Users']

# Select the state and quarter
selected_state = 'YourHomeState'  # Replace with your home state or state of interest
selected_year = 2023  # Replace with the year of interest
selected_quarter = 2  # Replace with the quarter of interest (1, 2, 3, or 4)

# Filter data for the selected state, year, and quarter
state_data = district_txn_users_df[
    (district_txn_users_df['State'] == selected_state) &
    (district_txn_users_df['Year'] == selected_year) &
    (district_txn_users_df['Quarter'] == selected_quarter)
]

# Assuming the data has a column 'TransactionType'
# Aggregate the transaction counts by transaction type
transaction_type_distribution = state_txn_split_df['Transaction Type'].value_counts()

# Create the pie chart
plt.figure(figsize=(10, 8))
plt.pie(transaction_type_distribution, labels=transaction_type_distribution.index, autopct='%1.1f%%', startangle=140)
plt.title(f'Distribution of Transaction Types in {selected_state} for {selected_year} Q{selected_quarter}')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

# Show the plot
plt.show()

# 5.3
import pandas as pd
import matplotlib.pyplot as plt
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Read the Excel file with multiple sheets
xls = pd.read_excel(excel_file, sheet_name=sheet_names)

# Access the 'District Demographics' sheet
district_demographics_df = xls['District Demographics']

# Select the state
selected_state = 'Maharashtra'  # Replace with the state you are interested in

# Filter data for the selected state
state_districts = district_demographics_df[district_demographics_df['State'] == selected_state]

# Calculate population density (Population / Area)
state_districts.loc[:, 'Density'] = state_districts['Population'] / state_districts['Area (sq km)']


# Check if the data is correct
print(f"Data for districts in {selected_state}:\n", state_districts[['District', 'Density']].head())

# Create the bar plot
plt.figure(figsize=(12, 6))
plt.bar(state_districts['District'], state_districts['Density'], color='skyblue')
plt.xlabel('District')
plt.ylabel('Density')
plt.title(f'Population Density of Districts in {selected_state}')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()



# Show the plot
plt.show()

# 6 (6.1) Insights and Conclusion
import pandas as pd
import matplotlib.pyplot as plt
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the 'State_Txn and Users' sheet
state_txn_users_df = xls['State_Txn and Users']

# Display the first few rows to understand the data structure
print(state_txn_users_df.head())

# Ensure 'Year' and 'Quarter' columns are present
if 'Year' not in state_txn_users_df.columns or 'Quarter' not in state_txn_users_df.columns:
    raise ValueError("Columns 'Year' and 'Quarter' must be present in the DataFrame.")

# Aggregate data by year
annual_data = state_txn_users_df.groupby('Year').agg({
    'Transactions': 'sum',
    'Amount (INR)': 'sum'
}).reset_index()

# Aggregate data by quarter
quarterly_data = state_txn_users_df.groupby(['Year', 'Quarter']).agg({
    'Transactions': 'sum',
    'Amount (INR)': 'sum'
}).reset_index()

# Plot annual trends
plt.figure(figsize=(14, 6))
plt.plot(annual_data['Year'], annual_data['Transactions'], marker='o', label='Transaction Count')
plt.plot(annual_data['Year'], annual_data['Amount (INR)'], marker='o', label='Transaction Amount')
plt.xlabel('Year')
plt.ylabel('Count / Amount')
plt.title('Annual Trends in Transactions')
plt.legend()
plt.grid(True)
plt.show()

# Plot quarterly trends
# Combine Year and Quarter for plotting
quarterly_data['Year_Quarter'] = quarterly_data['Year'].astype(str) + ' Q' + quarterly_data['Quarter'].astype(str)

plt.figure(figsize=(14, 6))
plt.plot(quarterly_data['Year_Quarter'], quarterly_data['Transactions'], marker='o', label='Transaction Count')
plt.plot(quarterly_data['Year_Quarter'], quarterly_data['Amount (INR)'], marker='o', label='Transaction Amount')
plt.xlabel('Year and Quarter')
plt.ylabel('Count / Amount')
plt.title('Quarterly Trends in Transactions')
plt.xticks(rotation=45)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# 6.2
import pandas as pd
import matplotlib.pyplot as plt
# Load the Excel file with the specified sheets
sheet_names = [
    'State_Txn and Users',
    'State_TxnSplit',
    'State_DeviceData',
    'District_Txn and Users',
    'District Demographics'
]

# Access each sheet
state_txn_users_df = xls['State_Txn and Users']
state_txn_split_df = xls['State_TxnSplit']
state_device_data_df = xls['State_DeviceData']
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']

# Access the datasets
district_txn_users_df = xls['District_Txn and Users']
district_demographics_df = xls['District Demographics']
# Display the first few rows of each dataset to understand their structure
print("Transaction Data:")
print(district_txn_users_df.head())

print("\nDemographic Data:")
print(district_demographics_df.head())

# Merge the datasets on the 'District' column (assuming it's present in both datasets)
merged_df = pd.merge(district_txn_users_df, district_demographics_df, on='District')

# Display the columns of the merged DataFrame
print("\nColumns in the merged DataFrame:")
print(merged_df.columns)

# Ensure required columns are present
required_columns = ['Density', 'Transactions']
missing_columns = [col for col in required_columns if col not in merged_df.columns]

if missing_columns:
    raise KeyError(f"Missing columns in the merged DataFrame: {', '.join(missing_columns)}")

# Calculate correlations between demographic and transaction metrics
correlation_matrix = merged_df[required_columns].corr()

# Display the correlation matrix
print("\nCorrelation Matrix:")
print(correlation_matrix)

# Summarize findings
# Correctly access the correlation value
if 'Density' in correlation_matrix.columns and 'Transactions' in correlation_matrix.columns:
    transaction_volume_corr = correlation_matrix.loc['Density', 'Transactions']
    print(f"\nCorrelation between Population Density and Transaction Volume: {transaction_volume_corr:.2f}")

    # Interpretation
    if transaction_volume_corr > 0:
        print("There is a positive correlation between population density and transaction volume.")
    elif transaction_volume_corr < 0:
        print("There is a negative correlation between population density and transaction volume.")
    else:
        print("There is no significant correlation between population density and transaction volume.")
else:
    print("Expected columns for correlation are not present in the DataFrame.")

# Display the columns of the merged DataFrame
print("Columns in the merged DataFrame:")
print(merged_df.columns)

# 6.3 Summarize Findings and Insights

1. Data Quality and Structure
Missing Values: Identified missing values in several datasets, with the highest percentages in specific columns.
Recommendation: Clean the data by imputing missing values or removing incomplete records to ensure analysis accuracy.

Data Types: Verified that columns are of correct data types (e.g., numeric columns for calculations).
Recommendation: Ensure consistent data types across datasets to prevent errors during analysis.

2. Transaction Trends
Total Transactions and Amount: Aggregated data to calculate the total number of transactions and total transaction amount over years and quarters.
Top States: Identified top 5 states with highest and lowest transaction volumes.
Recommendation: Focus marketing efforts and resources on high-transaction states to maximize revenue.

Transaction Types: Determined the most common transaction types for each state and quarter.
Recommendation: Tailor promotional strategies based on prevalent transaction types.

3. Device Usage and Demographics
Device Brand Analysis: Calculated the ratio of users to each device brand and displayed it in a bar chart.
Recommendation: Consider partnerships or promotions based on device brand popularity in each state.

Population Density Correlation: Analyzed correlation between population density and transaction volume.
Finding: The correlation value indicates the relationship between density and transactions.
Recommendation: Target districts with higher population density for increased transaction potential.

4. Average Transaction Value (ATV)
Average Transaction Value: Computed the average transaction amount per user for each state.
Top States: Identified states with the highest and lowest average transaction values.
Recommendation: Explore strategies to increase ATV in lower-performing states through customer engagement and targeted promotions.

5. App Usage Trends
App Opens Analysis: Analyzed the total number of app opens over years and quarters for a selected state.
Recommendation: Enhance app features or promotions in states with increasing app usage trends.

6. Transaction Types Distribution
Distribution Pie Chart: Created a pie chart showing the distribution of transaction types for a selected state and quarter.
Recommendation: Use insights from the pie chart to adjust transaction-type-specific strategies.

7. Population Density Visualization
Population Density Bar Plot: Visualized the population density of districts in a selected state.
Recommendation: Prioritize districts with high density for targeted campaigns and resource allocation.

8. Data Merging and Advanced Analysis
Ratio of Users to Population: Merged datasets to calculate the ratio of registered users to the population for each state.
Recommendation: Identify and address disparities in user-to-population ratios to optimize user acquisition strategies.

Correlation Between Population Density and Transaction Volume: Provided a summary of correlation findings and recommended actions based on the correlation value.

Actionable Recommendations:
Data Cleaning: Address missing values and ensure data types are consistent across all datasets.
Marketing Strategy: Focus on high-transaction states and popular device brands. Tailor marketing and promotional efforts based on transaction types and average transaction values.
Targeted Campaigns: Prioritize high-density districts for targeted marketing and resource allocation.
User Engagement: Enhance app features in states with increasing app usage trends.